## 1.1. DDD(domain-driven-design) Pattern

### 1.1.1.  DDD(domain-driven-design) 이란 무엇인가

- DDD (domain-driven-design) 는 **특히 복잡하고, 끊임없이 변화하는 비즈니스 규칙이 존재하며, 기업 내에서 해당 비즈니스가 계속해서 유지되고 발전될 것으로 예상되는 시스템을 개발하는 방법론**이다.

- DDD 는 핵심 접근법 (The core of the DDD approach) 은 도메인을 분석하고 해당 분석을 토대로 개념적 도메인 모델을 만드는 몇가지 일련의 기술을 사용한다.

- 그리고 만들어진 모델은 개발하려는 소프트웨어의 기반이 된다.

- DDD 방식의 접근법 (분석과 모델링)은 특히 크고 복잡한 도메인을 설계하는데에 적합하다.

- DDD 는 또한 복잡한 시스템을 관리하는데에도 도움이 되며 소프트웨어 개발 프로세스의 다른 측면으로도 해결 방법이 될 수 있다.
  - 도메인에 집중하기도 하면서, DDD 는 비즈니스 팀과 개발 팀이 의사소통 사이에서 오해를 할 수 있는 부분에 집중한다. DDD 가 사용하는 도메인 모델은 상세하고 풍부한 비즈니스 지식을 표현하기도 함과 동시에 실제 작성된 코드와 모델이 비슷해야 하기 때문이다.
  - 도메인 모델은 오랜 기간동안 계속 최신화가 될 수록 유리하다. 가치있는 도메인 지식을 포착함으로써, 그들은 추후에 마주할 시스템 유지보수 업무에도 도움이 될 것이다.
  - DDD 는 거대한 문제를 해결하는 도메인을 효과적으로 나누고 병렬적으로 일을 수행할 수 있게 하며, 비즈니스 가치를 부분적으로 전달할 수도 있다.

- 이러한 DDD 는 오랫동안 유지되고 복잡한 시스템에 적합한데, 만약 당신이 개발하려는 시스템이 작고, 단순하며, 짧은 기간동안에만 유지될 프로젝트라면 DDD 의 장점을 살리지 못할 것이다



## 1.1.2. DDD(domain-driven-design) 의 컨셉과 용어

- CQRS 패턴을 구현하기 위해서 필요한 몇가지 DDD 개념들을 알아두면 도움이 된다.
  - Domain Model, 도메인 모델
  - Ubiquitous Language, 유비쿼터스 언어
  - Entities, Value Object and services
  - Aggregate and Aggregate Roots



## 1.1.3. 도메인 모델

- DDD 의 중심에는 domain model 이라는 것이 존재한다.

- 도메인 모엘은 도메인 전문가, 비즈니스 전문가, 소프트웨어 개발자들의 토론과 여러가지의 질문들로 만들어지며 이러한 도메인 모델은 다음과 같은 역할울 수행하게 된다.
  - 도메인 전문가로부터 여러 도메인 지식을을 포착할 수 있다.
  - 팀이 도메인 지식에 대해서 align 할 수 있다.
  - 개발자는 해당 도메인 모델을 토대로 코드를 작성한다.
  - 도메인에 대한 엄청난 변화에도 즉각적으로 반영될 수 있다.

- DDD 는 도메인이 곧 비즈니스 가치이기 떄문에 도메인에 집중한다.

- 이러한 도메인 모델을 통해서 기업은 가치를 구현하고 숨어있는 비즈니스 가치를 찾아낸다.

- DDD 접근 방식의 대부분은 이러한 도메인 모델을 생성, 유지 및 사용하는 방법에 초점을 맞추고 있다.

- 도메인 모델은 일반적으로 Entities, Value Object and Aggregates 와 같은 요소로 구성되며 유비쿼터스 언어의 용어를 사용하여 설명한다.



## 1.4. Ubiquitous Language

- Ubiquitous Language 의 개념은 도메인 모델에 매우 밀접하게 닮아있다.

- 도메인 모델은 도메인 전문가와 개발자 사이에 대한 오해를 줄이고 같은 곳을 바라볼 수 있도록 간극을 좁히는 역할을 수행하기도 한다.

- 만약 도메인 전문가와 개발자가 도메인에 대해서 (앞서 Journey 파트에서 나온 콘토소 컨퍼런스 관리 시스템의 컨퍼런스, 참석자, 의자, 대기자 명단 과 같은) 동일한 용어를 사용한다면 오해에 대한 여지를 줄일 수 있게 된다.

- 좀 더 구체적으로는 모든 사람들이 동일한 개념의 언어를 사용한다면, 언어 간 번역으로 인한 오해가 있을 가능성이 적어진다. 예를 들어서 도메인 전문가가 참석자를 deletegtor 라고 표현하 하는데, 실제로 소프트웨어 개발자는 이를 티켓 판매원이라고 이해할 수 있고 결국 도메인에 대한 공통 개념이 없다 보니 시간이 지날수록 문제가 더 커질 수 있게 되는 것이다.

- 더 구체적으로, 모든 사람이 같은 언어를 사용한다면, 언어 간 번역으로 인한 오해가 있을 가능성이 적다. 예를 들어, 개발자가 "도그니 전문가가 델레 게이트에 대해 이야기한다면, 그는 실제로 소프트웨어의 참석자에 대해 이야기하고 있다"고 생각해야 한다면, 결국 이러한 명확성 부족으로 인해 무언가가 잘못될 것이다.

  

## 1.5. Entities, value objects, and services

- DDD 는 internal artifacts (or building blocks) 를 식별하기 위해서 다음과 같은 용어를 사용한다.

### 1.5.1. Entities

- 엔티티는 식별자를 가지는 객체를 의미한다. 예를 들어서 컨퍼런스 관리 시스템에서 conference 는 엔티티가 될 수 있다.

- conference 의 여러 속성들은 시간이 지남에 따라서 변할 수 있지만 해당 conference 자체는 시스템 안에서 고유할 것이다.

- 이러한 엔티티들은 항상 시스템의 메모리상에만 존재하지 않을 수 있다. 다른 시스템에 잠시 저장할 수도 있으며 DB 를 통해서 영속화 하고 필요할 때 시스템으로 다시 불러올 수도 있다.

### 1.5.2. Value Objects

- 꼭 모든 객체가 유일성을 보장해야 하지 않을 수도 있다.

- 예를 들어서 어떤 객체들은 단지 속성의 값으로만 존재할 수도 있다.

- 예를 들어서 우리의 컨퍼런스 관리 시스템에서 컨퍼런스 참석자의 주소에 대해서는 꼭 식별자를 갖지 않아도 된다.

- 대신 집중하는 것은 value object 는 불변성을 보장해야 한다는 것이다.

### 1.5.3. Services

- 항상 모든것 객체 형태로 관리하지 않아도 된다.

- 예를 들어, 회의 관리 시스템에서는 외부 결제 처리 시스템을 서비스로 모델링하는 것이 합리적일 수 있다.

- 서비스가 필요로 하는 파라미터만 넘기고 결과를 반환받아 특정 기능을 수행할 수도 있다.

- 이러한 서비스의 특징이라고 한다면 엔티티나 값 객체와 달리 stateless 하다는 것이다.

  

## 1.6. Aggregate 와 Aggregate Root

- Entitiy, Value Object 및 Service 가 DDD 가 도메인 모델에서 존재하는 구성요소를 설명하는 데에 사용되는 용어인 반면에 Aggregate 나 Aggregate Root 라는 용어는 특히 그러한 용어들의 그룹화와 life-cycle 에 관련이 있다.

- 만약 공유된 데이터에 대해서 다수의 사용자를 허용하는 시스템을 설계한다면 당신은 일관성(consistency) 와 사용성(usabililty) 사이의 트레이드 오프를 잘 파악해야 한다.

- 극단적인 예를 보면, 유저가 어떠한 데이터에 대한 수정을 하고 있을 때, 시스템은 해당 데이터를 다른 사용자가 사용하지 못하도록 system 단에서 lock 을 걸 수 있다.

- 하지만 해당 lock 이 풀릴 떄 까지 시스템의 가용성은 낮아지게 된다.

- 또 다른 극단적인 예를 보자, 만약 다른 사용자가 사용하는 자원에 대해서 lock 을 걸지 않는다면, 다른 사용자들은 어떠한 제약 없이 동시에 해당 데이터를 수정할 수도 있고 시스템의 일관성이 깨지게 될 것이다.

- 이런 상황에서 locking 을 할 것이냐 말 것이냐를 결정하기 위해서는 해당 도메인에 대한 지식이 필요하다.
  - 해당 트랜잭션을 통해서 어떤 값 객체나 엔티티가 영향을 받는지 알아야 한다.
  - 한 오브젝트로 부터 다른 엔티티나 값 객체에 얼마나 영향을 미치며 어디까지 consistency 를 보장하는 경계에 대해서도 인지해야 한다.

### 1.6.1. Aggregate

- DDD 는 일관성을 보장해야 하는 관련된 엔티티와 값 객체들을 하나로 묶는 용어로 aggregate 라는 용어를 사용한다.

- 해당 consistency 경계는 일반적으로 transactional consistency 를 기본으로 한다.

### 1.6.2. Aggregate Root

root entity 로 알려진 Aggregate Root 는 애그리거트에 접근할 수 있는 진입접 (gatekeeper) 을 의미한다.

한 애그리거트에 속해있는 값 객체나 엔티티에 접근하기 위해서는 무조건 Aggregate Root 를 통해서만 수행되어야 한다.

외부 엔티티는 Aggregate Root 대한 레퍼런스만 가질 수 있다.



> #### 요약하자면 aggregate 와 aggregate root 는 DDD 가 일반적으로 도메인 모델에 존재하는 수많은 엔티티와 값 객체 사이에 존재하는 복잡한 관계를 관리하는데 사용되는 메커니즘이다.



## 1.7. Bounded Contexts

- 지금까지 간략히 알아본 DDD 컨셉과 용어는 도메인 모델을 생성, 유지 및 사용하는 것과 관련이 있다.

- 대형 시스템에서는 도메인 모델을 단일로 관리하고 만들어 나가는 것은 실용적이지 않을 수 있다.

- 크기와 복잡성으로 인해서 consistency 역시 보장하고 유지하기가 어렵다.

- 이런 상황에서 DDD는 Bounded Context 에 대한 개념을 사용한다.

- 시스템 내에서 단일 대형 모델이 아닌, 여러 개의 작은 모델을 사용하여 해당 모델들이 적절한 협력을 거쳐서 기능을 수행하게 된다.

- 각각은 전체 시스템 내의 일부의 기능이나 비즈니스 가치에 집중할 수 있게 된다.

- Boundex Context, 바운디드 컨텍스트는 특정 도메인 모델의 문맥 (컨텍스트)이다.

- 각 바운디드 컨텍스트는 자체적인 유비쿼터스 언어를 가지게 될 수 있고 자체적인 개념이 존재할 수도 있다.

[![image](./assets_msa/figure28.png)](https://user-images.githubusercontent.com/48385288/187064826-4bff4c3f-e8d5-4340-9b69-dea986ab38e1.png)

- 위 그림은 우리가 journey 에서 구현한 컨퍼런스 관리 시스템이 여러 바운디드 컨텍스트로 분리된 것을 보여준다.

- 실제로는 위 그림에 나온 3개의 바운디드 컨테스트보다 훨씬 많을 것이다.

- 바운디드 컨테스트가 얼마나 커야하고 얼마나 작아야 하는지에 대한 규칙은 없다.

- 궁극적으로 비즈니스에 대한 가치와 요구사항 및 프로젝트 제약에 의해서 결정되는 것이다.



#### 1.7.1. Eric Evans 는 더 거대한 바운디드 컨텍스트에 대한 여러 사례들을 만들었다.

- 거대한 바운디드 컨텍스트
  - 통합 모델로 더 많은 것을 처리할 때 사용자 작업 간의 흐름이 더 부드럽다.
  - 두 개의 별개의 모델과 매핑보다 하나의 일관된 모델을 이해하는 것이 더 쉽다.
  - 두 모델을 해석하는 것은 어렵다. (어쩔 때는 불가능에 가깝다)
  - 두 모델을 사용하는 것은 팀의 커뮤니케이션 비용을 증가시킨다.

- 작은 바운디드 컨텍스트
  - 개발자 간의 커뮤니케이션 오버헤드가 줄어든다.
  - CI, 지속적 통합이 더욱 쉬워진다.
  - 큰 바운디드 컨텍스트는 더욱 추상적이게 될 수 있으며 더 다양한 기술을 요구할 수 있다.



## 1.8. 손상 방지 레이어(Anti-Corruption Layers)

- 서로 다른 바운디드 컨텍스트는 서로 다른 도메인 모델을 가지고 있는다.

- 만약 한 바운디드 컨텍스트에서 다른 바운디드 컨텍스트와 통신할 때, 한 도메인 모델의 특정 개념이 다른 도메인 모델의 개념으로 잘못 침투하는 것을 주의해야 한다.

- 이 때, Anti-Corruption Layers 는 두 도메인 모델 사이를 깨끗하게 만드는 게이트웨이 역할을 수행한다.



## 1.9. Context Maps

- 크고 복잡한 시스템은 다양한 방식으로 서로 상호작용하는 여러 경계 컨텍스트를 가질 수 있다.

- context map 은 각각의 바운디드 컨텍스트 사이의 관계를 설명하는 문서이다.

- 이는 diagram 이 될 수도 있고, 표가 될 수도 있으며 문자가 될 수 있다.

- 컨텍스트맵은 높은 수준에서 시스템을 시각화 하는데에 도움을 주며 바운디드 컨텍스트 사이를 명확히 하는 데 도움이 된다.

- 바운디드 컨텍스트가 데이터를 교환하고 공유하는 위치, 방법 그리고 한 도메인 모델에서 다른 도메인 모델로 이동할 때 데이터를 어디서 변환하는지를 보여준다.

- customer 과 같은 비즈니스 엔티티는 여러 바운디드 컨텍스트에 존재할 수 있다. 하지만 특정 바운디드 컨텍스트와 관련된 다른 속성값을 포함하고 표현할 수 있다.

- customer 엔티티가 한 바운디드 컨텍스트에서 다른 바운디드 컨텍스트로 이동할 때 현재 컨텍스트에 대한 속성을 노출하거나 숨기는 등 변환될 수도 있다.



## 1.10. Bounded Context 와 Multiple Architecture

- 바운디드 컨텍스트는 일반적으로 시스템 내의 다른 바운디드 컨텍스트와 명확하게 경계를 나타낸다. 
- 바운디드 컨텍스트가 DDD 접근법에 따라서 구현된다면, 바운디드 컨텍스트는 자제 도메인 모델과 자체 유비쿼터스 언어를 갖게 된다.

- 바운디드 컨텍스트의 구현은 일반적으로 데이터 저장소에서 UI 에 이르기 까지 모든 것이 포함된다.

- 또한 동일한 도메인 개념이 여러 바운디드 컨텍스트에 존재할 수 있다. 예를 들어서 컨퍼런스 관리 시스템에서 참석자의 개념은 예약을 다루는 다른 바운디드 컨텍스트에서 다른 의미로 사용될 수 있다.

- 각 바운디드 컨텍스트의 도메인 전문가의 관점에서 이러한 다양한 버전의 참석자는 다른 행동과 속성들이 필요할 수 있다.

- 예를 들어서 예약 바운디드 컨텍스트에서 참석자는 예약 및 결제를 하는 사용자를 의미한다. 결국 결제와 관련된 정보를 요구할 수도 있고 호텔 바운디드 컨텍스트에서 참석자는 흠연 선호도와 같은 정보가 중요할 수도 있다.

- 이러한 바운디드 컨텍스트를 보고 알 수 있는 중요한 것은 각각의 서로 다른 바운디드 컨텍스트는 다른 시스템 아키텍처가 적용될 수 있다는 것이다.

- 예를 들어서 하나의 바운디드 컨텍스트는 DDD 의 Layered Architecture 를 이용해서 구현될 수 있고, 다른 바운디드 컨텍스트는 단순 CRUD 아키텍처, 또 다른 바운디드 컨텍스트는 CQRS 패턴을 적용한 아키텍처를 사용할 수 있다는 것이다.

- 아래의 그림은 영속성 자장 장치부터 UI 까지, 포함된 모든 컴포넌트를 보여준다.

[![image](./assets_msa/figure29.png)](https://user-images.githubusercontent.com/48385288/187066142-712a959c-6052-406f-9060-b8ee16a860e9.png)

- 복잡성을 관리하는 것 이외에도, 시스템을 바운디드 컨텍스트로 나누는 또 다른 이점이 있다.

- 다른 요구사항에 따라서 적절한 아키텍처를 선택할 수도 있고, 특정 부분만 다른 기술을 사용할 수도 있다.

- 복잡성을 관리하는 것 외에도, 시스템을 경계된 맥락으로 나누는 또 다른 이점이 있다. 
  - 시스템의 다른 부분에 적절한 기술 아키텍처를 사용하여 각 부분의 특성을 광고할 수 있다. 
  - 예를 들어, 시스템의 복잡한 부분인지, 핵심 도메인 기능이 포함되어 있는지, 예상 수명과 같은 질문을 해결할 수 있습니다.



## 1.11. Bounded Context 와 multiple 개발팀

- 다른 바운디드 컨텍스트를 명확하게 분리하고 별도의 도메인 모델과 유비쿼터스 언어로 작업하면 각 경계 컨텍스트에 대해 별도의 팀을 사용하여 개발 작업을 병렬화할 수 있다.

  

## 1.12. 여러 바운디드 컨텍스트를 maintaining 하기

- 바운디드 컨텍스트는 더 관리하기 쉬운 부분으로 나뉘기 때문에 대규모 시스템의 복잡성을 관리하는데에 도움되지만, 각 바운디드 컨텍스트가 혼자 독립적으로 존재할 가능성은 거의 없다.

- 바운디드 컨텍스트는 서로 데이터를 교환해야 하며, 다른 도메인 모델에서 동일한 도메인 객체를 변환을 해야 하는 경우 이러한 데이터 변경은 꽤나 복잡할 것이다.

- 컨퍼런스 관리 시스템에서는 컨퍼런스 예약, 배지 인쇄 및 호텔 예약 문제를 다루는 경계된 맥락 간에 attendee 객체에 대한 속성을 변환해야 할 수도 있다.

- DDD 접근 방식은 Anti-Corruption Layers 를 사용하거나 [Shared Kernel](https://github.com/dhslrl321/cqrs-journey-guide-korean/blob/master/terms/Shared Kernel.md) 을 사용하는 것과 같은 여러 바운디드 컨텍스트 사이에서 여러 모델 간의 상호 작용을 처리하기 위한 다양한 접근 방식을 제공한다

> Note: 기술적인 관점에서 서로 다른 바운디드 컨텍스트 사이의 통신은 messaging infrastructure 를 이용한 비동기 통신을 주로 사용한다.
